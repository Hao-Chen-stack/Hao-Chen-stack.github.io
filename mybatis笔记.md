### 基本信息

MyBatis 是一款优秀的持久层框架；

它支持定制化 SQL、存储过程以及高级映射。

MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。

### 特点

简单易学

灵活

解除sql与程序代码的耦合

提供映射标签，支持对象与数据库的ORM字段关系映射

提供对象关系映射标签，支持对象关系组件维护

提供xml标签，支持编写动态sql

### 功能架构

**(1)API接口层**：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。

**(2)数据处理层**：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。

**(3)基础支撑层**：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。

### 框架架构

**(1)加载配置**：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。

**(2)SQL解析**：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。

​		（eg：SQL的ID为**类全路径名**和**方法名**。类全路径名称namespace，方法名标签ID。xml标签中ID是唯一的，所有在接口中方法重载后无法在xml文件中具体表示）

**(3)SQL执行**：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。

**(4)结果映射**：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。

### 缓存

mybatis一级缓存和二级缓存

**一级缓存**：作用域默认是一个SqlSession。Mybatis默认开启一级缓存。也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；第二次以后是直接去缓存中取。

一级缓存时执行commit，close，增删改等操作，就会清空当前的一级缓存；当对SqlSession执行更新操作（update、delete、insert）后并执行commit时，不仅清空其自身的一级缓存（执行更新操作的效果），也清空二级缓存（执行commit()的效果）。

**二级缓存**：mybatis默认是没有开启一级缓存的。在关闭sqlsession后(close)，才会把该sqlsession一级缓存中的数据添加到namespace的二级缓存中。

开启了二级缓存后，还需要将要缓存的bean实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中。

**扩展** ---》

​	**脏写**：事务B去修改了事务A修改过的值，而此时事务A还没有提交，所以事务A随时会回滚，导致事务B修改的值也没了。

​	**脏读**：事务B去查询了事务A修改过的值，而此时事务A还没有提交，所以事务A随时会混滚，导致事务B再次查询，就读不到刚才事务A修改过的数据了。

​	**不可重复度**：事务A在执行过程中多次读取一个数据，但是事务B和事务C等其他数据在事务A执行过程中会修改该数据并提交，导致事务A每次可能读取到的该数据的值都会变化。

​	**幻读**：一个事务用同一条SQL查询，结果每次查询都会发现一些之前没看到的数据。

为了防止脏读，所以mybatis执行事务提交时会清空缓存

**注意事项**：

映射语句文件中的所有 select 语句的结果将会被缓存。

映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。

缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。

缓存不会定时进行刷新（也就是说，没有刷新间隔）。

缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。

缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。

### 总体流程

(1)加载配置并初始化

​		加载配置文件，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。

(2)接收调用请求

​		调用mybatis提供的API，为SQL的ID和传入参数对象。将请求传递给下层的请求处理层进行处理

(3)处理操作请求

​		API接口传递请求过来，为SQL的ID和传入参数对象。

​		根据SQL的ID查找对应的MapperStatement对象。

​		根据传入参数对象解析MapperStatement对象，得到最终要执行的SQL和执行传入参数。

​		获取数据库连接，根据最终SQL语句和传入参数到数据库执行，得到执行结果

​		根据MapperStatement对象中的结构映射配置对结果进行转换处理，得到最终的处理结果

​		释放连接

(4)返回处理结果将最终的处理结果返回。

### ORM

对象关系映射，解决了对象和关系型数据库之间的数据交互问题。

### 类别名

```java
<!-- 1、typeAlias:为某个java类型起别名
    type:指定要起别名的类型全类名;默认别名就是类名小写；
    alias:指定新的别名
    typeAliases：别名处理器：可以为我们的java类型起别名 
            别名不区分大小写
 -->
 <typeAliases>
      <typeAlias alias="investByBsy" type="com.duanrong.cps.business.bsy.model.InvestByBsy"/>
 </<typeAliases>
```

### Mybatis动态代理

将所有和JDBC交互的操作，底层使用JDK动态代理封装，使用者只需定义.xml和Mapper文件

SQL语句定义在xml文件或者mapper中，项目启动时通过解析器解析SQL语句组装为Java中的对象

动态代理的实现

1、通过xml文件中 namspace 得到Class对象

​		1）拿到类全路径名称

​		2）根据mapper全路径信息得到Class对象

​		3）添加到对应的映射器容器（configuration）中，等待生成动态代理对象

![img](https://img-blog.csdnimg.cn/img_convert/6af5eaa746af08dffb8bafee3ece4618.png)

2、将得到的 Class 对象（实际就是接口对象）传递给 Mybatis 代理工厂生成代理对象（通过构造函数传递）

![img](https://img-blog.csdnimg.cn/img_convert/e621827194595f093c1949fc73dd4fbd.png)

以上解决了我们的接口无需实现类还可以调用。

